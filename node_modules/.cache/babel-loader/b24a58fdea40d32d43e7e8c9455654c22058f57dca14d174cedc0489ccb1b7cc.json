{"ast":null,"code":"const uniqueId = require('./unique-id');\nconst Component = require('./Component.jsx');\nconst instance = require('./instance');\nconst isString = require('./is-string');\nlet configs = [];\nlet queue = [];\nconst emptyQueue = () => {\n  const inst = instance.get();\n  if (!inst) {\n    return;\n  }\n  if (configs.length) {\n    configs.unshift(inst.state);\n    inst.setState(Object.assign.apply(null, configs));\n\n    // kill the configs\n    configs.length = 0;\n  }\n  if (queue.length) {\n    const toasts = inst.state.toasts;\n    queue.forEach(toast => {\n      toasts.push(Object.assign({}, inst.state, toast));\n    });\n    inst.setState({\n      toasts\n    });\n    // empty the queue\n    queue.length = 0;\n  }\n};\nconst pushToast = function (toast) {\n  queue.push(toast);\n  emptyQueue();\n};\nconst generateToast = function (title, message, obj) {\n  // if we have a title and it's not a string,\n  // then we've been passed an object to use as a toast\n  if (title && !isString(title)) {\n    return pushToast(\n    // if we've been passen an obj, then it's probably\n    // from generateToastType and we want to include\n    // the type\n    obj ? Object.assign({}, title, obj) : title);\n  }\n\n  // standard: title, message, obj passing\n  pushToast(Object.assign({\n    title,\n    message,\n    id: uniqueId()\n  }, obj));\n};\nconst generateToastType = function (typeStr) {\n  const type = {\n    type: typeStr\n  };\n  return (title, message, obj) => {\n    generateToast(title, message, obj ? Object.assign({}, obj, type) : type);\n  };\n};\n\n// when the instance mounts, the queue will be processed\ninstance.callback = emptyQueue;\nmodule.exports = Object.assign(generateToast, {\n  Component,\n  config(opts) {\n    configs.push(opts);\n    emptyQueue();\n  },\n  warning: generateToastType('warning'),\n  success: generateToastType('success'),\n  error: generateToastType('danger'),\n  info: generateToastType('info'),\n  remove() {\n    const inst = instance.get();\n    // success! lol, they're already gone\n    if (!inst) {\n      return;\n    }\n    // otherwise, set the toasts to be empty\n    inst.setState({\n      toasts: []\n    });\n  }\n});","map":{"version":3,"names":["uniqueId","require","Component","instance","isString","configs","queue","emptyQueue","inst","get","length","unshift","state","setState","Object","assign","apply","toasts","forEach","toast","push","pushToast","generateToast","title","message","obj","id","generateToastType","typeStr","type","callback","module","exports","config","opts","warning","success","error","info","remove"],"sources":["/Users/mihailsarenko/Desktop/color_generator/node_modules/react-toasty/src/index.js"],"sourcesContent":["const uniqueId = require('./unique-id');\r\nconst Component = require('./Component.jsx');\r\nconst instance = require('./instance');\r\nconst isString = require('./is-string');\r\n\r\nlet configs = [];\r\nlet queue = [];\r\n\r\nconst emptyQueue = () => {\r\n    const inst = instance.get();\r\n    if (!inst) { return; }\r\n\r\n    if (configs.length) {\r\n        configs.unshift(inst.state);\r\n        inst.setState(Object.assign.apply(null, configs));\r\n\r\n        // kill the configs\r\n        configs.length = 0;\r\n    }\r\n\r\n    if (queue.length) {\r\n        const toasts = inst.state.toasts;\r\n        queue.forEach(toast => {\r\n            toasts.push(\r\n                Object.assign({}, inst.state, toast)\r\n            );\r\n        });\r\n\r\n        inst.setState({ toasts });\r\n        // empty the queue\r\n        queue.length = 0;\r\n    }\r\n};\r\n\r\nconst pushToast = function(toast) {\r\n    queue.push(toast);\r\n    emptyQueue();\r\n};\r\n\r\nconst generateToast = function(title, message, obj) {\r\n    // if we have a title and it's not a string,\r\n    // then we've been passed an object to use as a toast\r\n    if (title && !isString(title)) {\r\n        return pushToast(\r\n            // if we've been passen an obj, then it's probably\r\n            // from generateToastType and we want to include\r\n            // the type\r\n            obj ? Object.assign({}, title, obj) : title\r\n        );\r\n    }\r\n\r\n    // standard: title, message, obj passing\r\n    pushToast(\r\n        Object.assign({\r\n            title,\r\n            message,\r\n            id: uniqueId()\r\n        }, obj)\r\n    );\r\n};\r\n\r\nconst generateToastType = function(typeStr) {\r\n    const type = { type: typeStr };\r\n    return (title, message, obj) => {\r\n        generateToast(title, message, obj ? Object.assign({}, obj, type) : type);\r\n    };\r\n};\r\n\r\n// when the instance mounts, the queue will be processed\r\ninstance.callback = emptyQueue;\r\n\r\nmodule.exports = Object.assign(generateToast, {\r\n    Component,\r\n\r\n    config(opts) {\r\n        configs.push(opts);\r\n        emptyQueue();\r\n    },\r\n\r\n    warning: generateToastType('warning'),\r\n    success: generateToastType('success'),\r\n    error: generateToastType('danger'),\r\n    info: generateToastType('info'),\r\n\r\n    remove() {\r\n        const inst = instance.get();\r\n        // success! lol, they're already gone\r\n        if (!inst) { return; }\r\n        // otherwise, set the toasts to be empty\r\n        inst.setState({ toasts: [] });\r\n    }\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}